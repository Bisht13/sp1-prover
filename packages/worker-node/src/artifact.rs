// This file is @generated by prost-build.
/// The artifact definition.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Artifact {
    /// The unique identifier for the artifact, representing its location in the S3 bucket.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// The label for the artifact (e.g., program, stdin, proof).
    #[prost(string, tag = "2")]
    pub label: ::prost::alloc::string::String,
    /// The expiration time for the artifact, as a Unix timestamp.
    #[prost(int32, optional, tag = "5")]
    pub expiry: ::core::option::Option<i32>,
}
/// The request for creating an artifact.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateArtifactRequest {
    /// The label for the artifact (e.g., program, stdin, proof).
    #[prost(string, tag = "1")]
    pub label: ::prost::alloc::string::String,
    /// When the artifact should expire, as a Unix timestamp.
    #[prost(uint32, tag = "2")]
    pub expiry: u32,
}
/// The response for creating an artifact.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateArtifactResponse {
    /// The created artifact.
    #[prost(message, optional, tag = "1")]
    pub artifact: ::core::option::Option<Artifact>,
}
/// The request for creating a batch of artifacts.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateArtifactBatchRequest {
    /// The number of artifacts to create.
    #[prost(uint32, tag = "1")]
    pub count: u32,
    /// The label for the artifacts.
    #[prost(string, tag = "2")]
    pub label: ::prost::alloc::string::String,
    /// When the artifacts should expire, as a Unix timestamp.
    #[prost(uint32, tag = "3")]
    pub expiry: u32,
}
/// The response for creating a batch of artifacts.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateArtifactBatchResponse {
    /// The created artifacts.
    #[prost(message, repeated, tag = "1")]
    pub artifacts: ::prost::alloc::vec::Vec<Artifact>,
}
/// Task-related information.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TaskData {
    /// The type of task.
    #[prost(enumeration = "TaskType", tag = "1")]
    pub task_type: i32,
    /// The inputs to the task.
    #[prost(message, repeated, tag = "2")]
    pub inputs: ::prost::alloc::vec::Vec<Artifact>,
    /// The outputs of the task.
    #[prost(message, repeated, tag = "3")]
    pub outputs: ::prost::alloc::vec::Vec<Artifact>,
    /// Metadata json string.
    #[prost(string, tag = "4")]
    pub metadata: ::prost::alloc::string::String,
}
/// Task request information.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TaskRequestData {
    /// The type of task.
    #[prost(enumeration = "TaskType", tag = "1")]
    pub task_type: i32,
    /// The input artifact identifiers for the task.
    #[prost(string, repeated, tag = "2")]
    pub input_artifact_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// The output artifact identifiers for the task.
    #[prost(string, repeated, tag = "3")]
    pub output_artifact_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Metadata json string.
    #[prost(string, tag = "4")]
    pub metadata: ::prost::alloc::string::String,
    /// The weight of the task.
    #[prost(uint32, tag = "5")]
    pub weight: u32,
}
/// The task definition.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Task {
    /// The unique identifier for the task.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// The parent task identifier, if any.
    #[prost(string, optional, tag = "2")]
    pub parent_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Proof ID.
    #[prost(string, tag = "3")]
    pub proof_id: ::prost::alloc::string::String,
    /// The task data.
    #[prost(message, optional, tag = "4")]
    pub data: ::core::option::Option<TaskData>,
    /// The task status.
    #[prost(enumeration = "TaskStatus", tag = "5")]
    pub status: i32,
}
/// The request for creating a task.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateTaskRequest {
    /// The parent task identifier, if any (used for non-controller tasks).
    #[prost(string, optional, tag = "1")]
    pub parent_id: ::core::option::Option<::prost::alloc::string::String>,
    /// The proof identifier.
    #[prost(string, tag = "2")]
    pub proof_id: ::prost::alloc::string::String,
    /// The task request data.
    #[prost(message, optional, tag = "3")]
    pub data: ::core::option::Option<TaskRequestData>,
}
/// The response for creating a task.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateTaskResponse {
    /// The created task identifier.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
/// The request for creating a batch of tasks.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateTaskBatchRequest {
    /// The parent task identifier, if any (used for non-controller tasks).
    #[prost(string, optional, tag = "1")]
    pub parent_id: ::core::option::Option<::prost::alloc::string::String>,
    /// The proof identifier.
    #[prost(string, tag = "2")]
    pub proof_id: ::prost::alloc::string::String,
    /// The task request data for the batch.
    #[prost(message, repeated, tag = "3")]
    pub data: ::prost::alloc::vec::Vec<TaskRequestData>,
}
/// The response for creating a batch of tasks.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateTaskBatchResponse {
    /// The identifier for the created task batch.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
/// The request for popping tasks from the queue.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PopTasksRequest {
    /// The type of worker.
    #[prost(enumeration = "WorkerType", tag = "1")]
    pub worker_type: i32,
    /// Max weight of tasks to pop.
    #[prost(uint32, tag = "2")]
    pub max_weight: u32,
}
/// The response for popping tasks from the queue.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PopTasksResponse {
    /// The tasks that were popped.
    #[prost(message, repeated, tag = "1")]
    pub tasks: ::prost::alloc::vec::Vec<Task>,
}
/// The request for bumping a task.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BumpTasksRequest {
    /// The task identifier.
    #[prost(string, repeated, tag = "1")]
    pub task_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// The response for bumping a task; empty on success.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BumpTasksResponse {}
/// The request for fetching a task status.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FetchTaskStatusRequest {
    /// The task identifier.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
/// The response for fetching a task status.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FetchTaskStatusResponse {
    /// The status of the task.
    #[prost(enumeration = "TaskStatus", tag = "1")]
    pub status: i32,
}
/// The request for fetching the statuses of a batch of tasks.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FetchTaskBatchStatusRequest {
    /// The task batch identifier.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
/// The response for fetching the statuses of a batch of tasks.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FetchTaskBatchStatusResponse {
    /// The statuses of the tasks in the batch.
    #[prost(enumeration = "TaskStatus", repeated, tag = "1")]
    pub statuses: ::prost::alloc::vec::Vec<i32>,
}
/// The request for fetching the statuses of many tasks.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FetchTaskStatusesRequest {
    /// The task identifiers.
    #[prost(string, repeated, tag = "1")]
    pub ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// The response for fetching the statuses of many tasks.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FetchTaskStatusesResponse {
    /// The statuses of the tasks.
    #[prost(enumeration = "TaskStatus", repeated, tag = "1")]
    pub statuses: ::prost::alloc::vec::Vec<i32>,
}
/// The request for updating a task status.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateTaskStatusRequest {
    /// The task identifier.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// The new status for the task.
    #[prost(enumeration = "TaskStatus", tag = "2")]
    pub status: i32,
}
/// The response for updating a task status; empty on success.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateTaskStatusResponse {}
/// The request for expiring dropped tasks.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExpireDroppedTasksRequest {}
/// The response for expiring dropped tasks; empty on success.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExpireDroppedTasksResponse {}
/// The request for getting fulfillable proof requests. These are proof requests that are in a
/// claimed state and have a successful proof.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFulfillableProofRequestsRequest {}
/// The response for getting fulfillable proof requests.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFulfillableProofRequestsResponse {
    /// The proof requests that are fulfillable.
    #[prost(string, repeated, tag = "1")]
    pub proof_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// The request for getting failed proof requests. These are proof requests that are in a claimed
/// state and have been retried too many times.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFailedProofRequestsRequest {}
/// The response for getting failed proof requests.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFailedProofRequestsResponse {
    /// The proof requests that are expired.
    #[prost(string, repeated, tag = "1")]
    pub proof_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// The request for creating a claimed proof; should be called only after it has been successfully claimed
/// from the Network.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateClaimedProofRequest {
    /// The proof identifier.
    #[prost(string, tag = "1")]
    pub proof_id: ::prost::alloc::string::String,
    /// The program artifact identifier.
    #[prost(string, tag = "2")]
    pub program_artifact_id: ::prost::alloc::string::String,
    /// The stdin artifact identifier.
    #[prost(string, tag = "3")]
    pub stdin_artifact_id: ::prost::alloc::string::String,
    /// The proof output artifact identifier.
    #[prost(string, tag = "4")]
    pub proof_artifact_id: ::prost::alloc::string::String,
    /// The proof requester address.
    #[prost(bytes = "vec", tag = "5")]
    pub requester_address: ::prost::alloc::vec::Vec<u8>,
}
/// The response for creating a claimed proof; empty on success.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateClaimedProofResponse {}
/// The request for updating a proof request to a given status.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateProofStatusRequest {
    /// The proof identifier.
    #[prost(string, tag = "1")]
    pub proof_id: ::prost::alloc::string::String,
    /// The new status for the proof request.
    #[prost(enumeration = "ProofRequestStatus", tag = "2")]
    pub status: i32,
}
/// The response for updating a proof request; empty on success.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateProofStatusResponse {}
/// The request for modifying the number of CPU cycles used this month for a proof requester.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModifyCpuCyclesRequest {
    /// The updated amount of CPU cycles used for this proof request.
    #[prost(int64, tag = "1")]
    pub cycles: i64,
    /// The proof identifier.
    #[prost(string, tag = "2")]
    pub proof_id: ::prost::alloc::string::String,
}
/// The response for modifying the number of CPU cycles used this month for an account. If the account
/// is out of cycles for this month, ok will be false.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModifyCpuCyclesResponse {
    /// Whether the account is out of cycles for this month.
    #[prost(bool, tag = "1")]
    pub exceeded_limit: bool,
    /// The number of CPU cycles used this month for the account, including requested cycles.
    #[prost(int64, tag = "2")]
    pub used: i64,
    /// The number of max CPU cycles this account can use this month.
    #[prost(int64, tag = "3")]
    pub limit: i64,
}
/// The types of tasks.
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum TaskType {
    /// Unspecified or invalid task type.
    UnspecifiedTaskType = 0,
    /// Execute the program, shard events, and launch commit tasks.
    Sp1ControllerExecute = 1,
    /// Wait for commit tasks to complete, then launch open tasks.
    Sp1ControllerCommit = 2,
    /// Wait for open tasks to complete, then return proof or launch recursion tasks.
    Sp1ControllerOpen = 3,
    /// Wait for recursion core tasks, then launch deferred tasks or continue to reduce.
    Sp1ControllerRecursionCore = 4,
    /// Wait for deferred tasks, then reduce.
    Sp1ControllerRecursionDeferred = 5,
    /// Wait for reduce, then reduce again or return proof or continue to plonk.
    Sp1ControllerRecursionReduce = 6,
    /// Shrink compressed proof and then wrap.
    Sp1ControllerShrink = 7,
    /// Wrap shrunken proof and then continue to plonk.
    Sp1ControllerWrap = 8,
    /// Generate plonk proof from wrapped proof and fulfill.
    Sp1ControllerPlonk = 9,
    /// Commit a shard. If given a checkpoint rather than record, generate non-precompile events first.
    Sp1CommitShard = 10,
    /// From a runtime checkpoint, generate precompile events for a shard and upload.
    Sp1PrecompileShard = 11,
    /// An open-multi task.
    Sp1OpenMultiShard = 12,
    /// Verify a batch of core proofs.
    Sp1RecursionCoreBatch = 13,
    /// Verify a batch of deferred proofs.
    Sp1RecursionDeferredBatch = 14,
    /// Verify a batch of recursive proofs.
    Sp1RecursionReduceBatch = 15,
}
impl TaskType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            TaskType::UnspecifiedTaskType => "UNSPECIFIED_TASK_TYPE",
            TaskType::Sp1ControllerExecute => "SP1_CONTROLLER_EXECUTE",
            TaskType::Sp1ControllerCommit => "SP1_CONTROLLER_COMMIT",
            TaskType::Sp1ControllerOpen => "SP1_CONTROLLER_OPEN",
            TaskType::Sp1ControllerRecursionCore => "SP1_CONTROLLER_RECURSION_CORE",
            TaskType::Sp1ControllerRecursionDeferred => "SP1_CONTROLLER_RECURSION_DEFERRED",
            TaskType::Sp1ControllerRecursionReduce => "SP1_CONTROLLER_RECURSION_REDUCE",
            TaskType::Sp1ControllerShrink => "SP1_CONTROLLER_SHRINK",
            TaskType::Sp1ControllerWrap => "SP1_CONTROLLER_WRAP",
            TaskType::Sp1ControllerPlonk => "SP1_CONTROLLER_PLONK",
            TaskType::Sp1CommitShard => "SP1_COMMIT_SHARD",
            TaskType::Sp1PrecompileShard => "SP1_PRECOMPILE_SHARD",
            TaskType::Sp1OpenMultiShard => "SP1_OPEN_MULTI_SHARD",
            TaskType::Sp1RecursionCoreBatch => "SP1_RECURSION_CORE_BATCH",
            TaskType::Sp1RecursionDeferredBatch => "SP1_RECURSION_DEFERRED_BATCH",
            TaskType::Sp1RecursionReduceBatch => "SP1_RECURSION_REDUCE_BATCH",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNSPECIFIED_TASK_TYPE" => Some(Self::UnspecifiedTaskType),
            "SP1_CONTROLLER_EXECUTE" => Some(Self::Sp1ControllerExecute),
            "SP1_CONTROLLER_COMMIT" => Some(Self::Sp1ControllerCommit),
            "SP1_CONTROLLER_OPEN" => Some(Self::Sp1ControllerOpen),
            "SP1_CONTROLLER_RECURSION_CORE" => Some(Self::Sp1ControllerRecursionCore),
            "SP1_CONTROLLER_RECURSION_DEFERRED" => Some(Self::Sp1ControllerRecursionDeferred),
            "SP1_CONTROLLER_RECURSION_REDUCE" => Some(Self::Sp1ControllerRecursionReduce),
            "SP1_CONTROLLER_SHRINK" => Some(Self::Sp1ControllerShrink),
            "SP1_CONTROLLER_WRAP" => Some(Self::Sp1ControllerWrap),
            "SP1_CONTROLLER_PLONK" => Some(Self::Sp1ControllerPlonk),
            "SP1_COMMIT_SHARD" => Some(Self::Sp1CommitShard),
            "SP1_PRECOMPILE_SHARD" => Some(Self::Sp1PrecompileShard),
            "SP1_OPEN_MULTI_SHARD" => Some(Self::Sp1OpenMultiShard),
            "SP1_RECURSION_CORE_BATCH" => Some(Self::Sp1RecursionCoreBatch),
            "SP1_RECURSION_DEFERRED_BATCH" => Some(Self::Sp1RecursionDeferredBatch),
            "SP1_RECURSION_REDUCE_BATCH" => Some(Self::Sp1RecursionReduceBatch),
            _ => None,
        }
    }
}
/// The possible statuses of a task.
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum TaskStatus {
    /// Unspecified or invalid status.
    UnspecifiedStatus = 0,
    /// The task has been created.
    Created = 1,
    /// The task has not started.
    Pending = 2,
    /// The task is running.
    Running = 3,
    /// The task has completed successfully.
    Succeeded = 4,
    /// The task has failed but can be retried.
    FailedRetryable = 5,
    /// The task has failed and will need to be re-submitted.
    FailedFatal = 6,
}
impl TaskStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            TaskStatus::UnspecifiedStatus => "UNSPECIFIED_STATUS",
            TaskStatus::Created => "CREATED",
            TaskStatus::Pending => "PENDING",
            TaskStatus::Running => "RUNNING",
            TaskStatus::Succeeded => "SUCCEEDED",
            TaskStatus::FailedRetryable => "FAILED_RETRYABLE",
            TaskStatus::FailedFatal => "FAILED_FATAL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNSPECIFIED_STATUS" => Some(Self::UnspecifiedStatus),
            "CREATED" => Some(Self::Created),
            "PENDING" => Some(Self::Pending),
            "RUNNING" => Some(Self::Running),
            "SUCCEEDED" => Some(Self::Succeeded),
            "FAILED_RETRYABLE" => Some(Self::FailedRetryable),
            "FAILED_FATAL" => Some(Self::FailedFatal),
            _ => None,
        }
    }
}
/// The mode used when generating the proof.
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum ProofMode {
    /// Unspecified or invalid proof mode.
    Unspecified = 0,
    /// The proof mode for an SP1 core proof.
    Core = 1,
    /// The proof mode for a compressed proof.
    Compressed = 2,
    /// The proof mode for a PlonK proof.
    Plonk = 3,
}
impl ProofMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ProofMode::Unspecified => "PROOF_MODE_UNSPECIFIED",
            ProofMode::Core => "PROOF_MODE_CORE",
            ProofMode::Compressed => "PROOF_MODE_COMPRESSED",
            ProofMode::Plonk => "PROOF_MODE_PLONK",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PROOF_MODE_UNSPECIFIED" => Some(Self::Unspecified),
            "PROOF_MODE_CORE" => Some(Self::Core),
            "PROOF_MODE_COMPRESSED" => Some(Self::Compressed),
            "PROOF_MODE_PLONK" => Some(Self::Plonk),
            _ => None,
        }
    }
}
/// The type of worker.
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum WorkerType {
    /// Unspecified or invalid worker type.
    Unspecified = 0,
    /// The worker type for a CPU worker. Processes all controller tasks and precompile event task.
    Cpu = 1,
    /// The worker type for a GPU worker. Processes all commit/prove tasks. (except for PLONK currently)
    Gpu = 2,
    /// The worker type that accepts tasks meant only for Modal.
    Modal = 3,
    /// Worker type that can handle any task.
    All = 4,
}
impl WorkerType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            WorkerType::Unspecified => "WORKER_TYPE_UNSPECIFIED",
            WorkerType::Cpu => "WORKER_TYPE_CPU",
            WorkerType::Gpu => "WORKER_TYPE_GPU",
            WorkerType::Modal => "WORKER_TYPE_MODAL",
            WorkerType::All => "WORKER_TYPE_ALL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "WORKER_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "WORKER_TYPE_CPU" => Some(Self::Cpu),
            "WORKER_TYPE_GPU" => Some(Self::Gpu),
            "WORKER_TYPE_MODAL" => Some(Self::Modal),
            "WORKER_TYPE_ALL" => Some(Self::All),
            _ => None,
        }
    }
}
/// The possible statuses for a claimed proof request.
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum ProofRequestStatus {
    /// Unspecified or invalid status.
    UnspecifiedProofStatus = 0,
    /// The proof request was claimed by this cluster from the Network.
    Claimed = 1,
    /// The proof request was unclaimed by this cluster from the Network.
    Unclaimed = 2,
    /// The proof request was fulfilled by this cluster on the Network.
    Fulfilled = 3,
}
impl ProofRequestStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ProofRequestStatus::UnspecifiedProofStatus => "UNSPECIFIED_PROOF_STATUS",
            ProofRequestStatus::Claimed => "CLAIMED",
            ProofRequestStatus::Unclaimed => "UNCLAIMED",
            ProofRequestStatus::Fulfilled => "FULFILLED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNSPECIFIED_PROOF_STATUS" => Some(Self::UnspecifiedProofStatus),
            "CLAIMED" => Some(Self::Claimed),
            "UNCLAIMED" => Some(Self::Unclaimed),
            "FULFILLED" => Some(Self::Fulfilled),
            _ => None,
        }
    }
}
pub use twirp;
pub const SERVICE_FQN: &str = "/cluster.ClusterService";
#[twirp::async_trait::async_trait]
pub trait ClusterService {
    async fn create_artifact(
        &self,
        ctx: twirp::Context,
        req: CreateArtifactRequest,
    ) -> Result<CreateArtifactResponse, twirp::TwirpErrorResponse>;
    async fn create_artifact_batch(
        &self,
        ctx: twirp::Context,
        req: CreateArtifactBatchRequest,
    ) -> Result<CreateArtifactBatchResponse, twirp::TwirpErrorResponse>;
    async fn create_task(
        &self,
        ctx: twirp::Context,
        req: CreateTaskRequest,
    ) -> Result<CreateTaskResponse, twirp::TwirpErrorResponse>;
    async fn create_task_batch(
        &self,
        ctx: twirp::Context,
        req: CreateTaskBatchRequest,
    ) -> Result<CreateTaskBatchResponse, twirp::TwirpErrorResponse>;
    async fn pop_tasks(
        &self,
        ctx: twirp::Context,
        req: PopTasksRequest,
    ) -> Result<PopTasksResponse, twirp::TwirpErrorResponse>;
    async fn bump_tasks(
        &self,
        ctx: twirp::Context,
        req: BumpTasksRequest,
    ) -> Result<BumpTasksResponse, twirp::TwirpErrorResponse>;
    async fn fetch_task_status(
        &self,
        ctx: twirp::Context,
        req: FetchTaskStatusRequest,
    ) -> Result<FetchTaskStatusResponse, twirp::TwirpErrorResponse>;
    async fn fetch_task_batch_status(
        &self,
        ctx: twirp::Context,
        req: FetchTaskBatchStatusRequest,
    ) -> Result<FetchTaskBatchStatusResponse, twirp::TwirpErrorResponse>;
    async fn fetch_task_statuses(
        &self,
        ctx: twirp::Context,
        req: FetchTaskStatusesRequest,
    ) -> Result<FetchTaskStatusesResponse, twirp::TwirpErrorResponse>;
    async fn update_task_status(
        &self,
        ctx: twirp::Context,
        req: UpdateTaskStatusRequest,
    ) -> Result<UpdateTaskStatusResponse, twirp::TwirpErrorResponse>;
    async fn expire_dropped_tasks(
        &self,
        ctx: twirp::Context,
        req: ExpireDroppedTasksRequest,
    ) -> Result<ExpireDroppedTasksResponse, twirp::TwirpErrorResponse>;
    async fn get_fulfillable_proof_requests(
        &self,
        ctx: twirp::Context,
        req: GetFulfillableProofRequestsRequest,
    ) -> Result<GetFulfillableProofRequestsResponse, twirp::TwirpErrorResponse>;
    async fn get_failed_proof_requests(
        &self,
        ctx: twirp::Context,
        req: GetFailedProofRequestsRequest,
    ) -> Result<GetFailedProofRequestsResponse, twirp::TwirpErrorResponse>;
    async fn create_claimed_proof(
        &self,
        ctx: twirp::Context,
        req: CreateClaimedProofRequest,
    ) -> Result<CreateClaimedProofResponse, twirp::TwirpErrorResponse>;
    async fn update_proof_status(
        &self,
        ctx: twirp::Context,
        req: UpdateProofStatusRequest,
    ) -> Result<UpdateProofStatusResponse, twirp::TwirpErrorResponse>;
    async fn modify_cpu_cycles(
        &self,
        ctx: twirp::Context,
        req: ModifyCpuCyclesRequest,
    ) -> Result<ModifyCpuCyclesResponse, twirp::TwirpErrorResponse>;
}
pub fn router<T>(api: std::sync::Arc<T>) -> twirp::Router
where
    T: ClusterService + Send + Sync + 'static,
{
    twirp::details::TwirpRouterBuilder::new(api)
        .route(
            "/CreateArtifact",
            |api: std::sync::Arc<T>, ctx: twirp::Context, req: CreateArtifactRequest| async move {
                api.create_artifact(ctx, req).await
            },
        )
        .route(
            "/CreateArtifactBatch",
            |
                api: std::sync::Arc<T>,
                ctx: twirp::Context,
                req: CreateArtifactBatchRequest|
            async move { api.create_artifact_batch(ctx, req).await },
        )
        .route(
            "/CreateTask",
            |api: std::sync::Arc<T>, ctx: twirp::Context, req: CreateTaskRequest| async move {
                api.create_task(ctx, req).await
            },
        )
        .route(
            "/CreateTaskBatch",
            |api: std::sync::Arc<T>, ctx: twirp::Context, req: CreateTaskBatchRequest| async move {
                api.create_task_batch(ctx, req).await
            },
        )
        .route(
            "/PopTasks",
            |api: std::sync::Arc<T>, ctx: twirp::Context, req: PopTasksRequest| async move {
                api.pop_tasks(ctx, req).await
            },
        )
        .route(
            "/BumpTasks",
            |api: std::sync::Arc<T>, ctx: twirp::Context, req: BumpTasksRequest| async move {
                api.bump_tasks(ctx, req).await
            },
        )
        .route(
            "/FetchTaskStatus",
            |api: std::sync::Arc<T>, ctx: twirp::Context, req: FetchTaskStatusRequest| async move {
                api.fetch_task_status(ctx, req).await
            },
        )
        .route(
            "/FetchTaskBatchStatus",
            |
                api: std::sync::Arc<T>,
                ctx: twirp::Context,
                req: FetchTaskBatchStatusRequest|
            async move { api.fetch_task_batch_status(ctx, req).await },
        )
        .route(
            "/FetchTaskStatuses",
            |api: std::sync::Arc<T>, ctx: twirp::Context, req: FetchTaskStatusesRequest| async move {
                api.fetch_task_statuses(ctx, req).await
            },
        )
        .route(
            "/UpdateTaskStatus",
            |api: std::sync::Arc<T>, ctx: twirp::Context, req: UpdateTaskStatusRequest| async move {
                api.update_task_status(ctx, req).await
            },
        )
        .route(
            "/ExpireDroppedTasks",
            |
                api: std::sync::Arc<T>,
                ctx: twirp::Context,
                req: ExpireDroppedTasksRequest|
            async move { api.expire_dropped_tasks(ctx, req).await },
        )
        .route(
            "/GetFulfillableProofRequests",
            |
                api: std::sync::Arc<T>,
                ctx: twirp::Context,
                req: GetFulfillableProofRequestsRequest|
            async move { api.get_fulfillable_proof_requests(ctx, req).await },
        )
        .route(
            "/GetFailedProofRequests",
            |
                api: std::sync::Arc<T>,
                ctx: twirp::Context,
                req: GetFailedProofRequestsRequest|
            async move { api.get_failed_proof_requests(ctx, req).await },
        )
        .route(
            "/CreateClaimedProof",
            |
                api: std::sync::Arc<T>,
                ctx: twirp::Context,
                req: CreateClaimedProofRequest|
            async move { api.create_claimed_proof(ctx, req).await },
        )
        .route(
            "/UpdateProofStatus",
            |api: std::sync::Arc<T>, ctx: twirp::Context, req: UpdateProofStatusRequest| async move {
                api.update_proof_status(ctx, req).await
            },
        )
        .route(
            "/ModifyCpuCycles",
            |api: std::sync::Arc<T>, ctx: twirp::Context, req: ModifyCpuCyclesRequest| async move {
                api.modify_cpu_cycles(ctx, req).await
            },
        )
        .build()
}
#[twirp::async_trait::async_trait]
pub trait ClusterServiceClient: Send + Sync + std::fmt::Debug {
    async fn create_artifact(
        &self,
        req: CreateArtifactRequest,
    ) -> Result<CreateArtifactResponse, twirp::ClientError>;
    async fn create_artifact_batch(
        &self,
        req: CreateArtifactBatchRequest,
    ) -> Result<CreateArtifactBatchResponse, twirp::ClientError>;
    async fn create_task(
        &self,
        req: CreateTaskRequest,
    ) -> Result<CreateTaskResponse, twirp::ClientError>;
    async fn create_task_batch(
        &self,
        req: CreateTaskBatchRequest,
    ) -> Result<CreateTaskBatchResponse, twirp::ClientError>;
    async fn pop_tasks(&self, req: PopTasksRequest)
        -> Result<PopTasksResponse, twirp::ClientError>;
    async fn bump_tasks(
        &self,
        req: BumpTasksRequest,
    ) -> Result<BumpTasksResponse, twirp::ClientError>;
    async fn fetch_task_status(
        &self,
        req: FetchTaskStatusRequest,
    ) -> Result<FetchTaskStatusResponse, twirp::ClientError>;
    async fn fetch_task_batch_status(
        &self,
        req: FetchTaskBatchStatusRequest,
    ) -> Result<FetchTaskBatchStatusResponse, twirp::ClientError>;
    async fn fetch_task_statuses(
        &self,
        req: FetchTaskStatusesRequest,
    ) -> Result<FetchTaskStatusesResponse, twirp::ClientError>;
    async fn update_task_status(
        &self,
        req: UpdateTaskStatusRequest,
    ) -> Result<UpdateTaskStatusResponse, twirp::ClientError>;
    async fn expire_dropped_tasks(
        &self,
        req: ExpireDroppedTasksRequest,
    ) -> Result<ExpireDroppedTasksResponse, twirp::ClientError>;
    async fn get_fulfillable_proof_requests(
        &self,
        req: GetFulfillableProofRequestsRequest,
    ) -> Result<GetFulfillableProofRequestsResponse, twirp::ClientError>;
    async fn get_failed_proof_requests(
        &self,
        req: GetFailedProofRequestsRequest,
    ) -> Result<GetFailedProofRequestsResponse, twirp::ClientError>;
    async fn create_claimed_proof(
        &self,
        req: CreateClaimedProofRequest,
    ) -> Result<CreateClaimedProofResponse, twirp::ClientError>;
    async fn update_proof_status(
        &self,
        req: UpdateProofStatusRequest,
    ) -> Result<UpdateProofStatusResponse, twirp::ClientError>;
    async fn modify_cpu_cycles(
        &self,
        req: ModifyCpuCyclesRequest,
    ) -> Result<ModifyCpuCyclesResponse, twirp::ClientError>;
}
#[twirp::async_trait::async_trait]
impl ClusterServiceClient for twirp::client::Client {
    async fn create_artifact(
        &self,
        req: CreateArtifactRequest,
    ) -> Result<CreateArtifactResponse, twirp::ClientError> {
        let url = self
            .base_url
            .join("cluster.ClusterService/CreateArtifact")?;
        self.request(url, req).await
    }
    async fn create_artifact_batch(
        &self,
        req: CreateArtifactBatchRequest,
    ) -> Result<CreateArtifactBatchResponse, twirp::ClientError> {
        let url = self
            .base_url
            .join("cluster.ClusterService/CreateArtifactBatch")?;
        self.request(url, req).await
    }
    async fn create_task(
        &self,
        req: CreateTaskRequest,
    ) -> Result<CreateTaskResponse, twirp::ClientError> {
        let url = self.base_url.join("cluster.ClusterService/CreateTask")?;
        self.request(url, req).await
    }
    async fn create_task_batch(
        &self,
        req: CreateTaskBatchRequest,
    ) -> Result<CreateTaskBatchResponse, twirp::ClientError> {
        let url = self
            .base_url
            .join("cluster.ClusterService/CreateTaskBatch")?;
        self.request(url, req).await
    }
    async fn pop_tasks(
        &self,
        req: PopTasksRequest,
    ) -> Result<PopTasksResponse, twirp::ClientError> {
        let url = self.base_url.join("cluster.ClusterService/PopTasks")?;
        self.request(url, req).await
    }
    async fn bump_tasks(
        &self,
        req: BumpTasksRequest,
    ) -> Result<BumpTasksResponse, twirp::ClientError> {
        let url = self.base_url.join("cluster.ClusterService/BumpTasks")?;
        self.request(url, req).await
    }
    async fn fetch_task_status(
        &self,
        req: FetchTaskStatusRequest,
    ) -> Result<FetchTaskStatusResponse, twirp::ClientError> {
        let url = self
            .base_url
            .join("cluster.ClusterService/FetchTaskStatus")?;
        self.request(url, req).await
    }
    async fn fetch_task_batch_status(
        &self,
        req: FetchTaskBatchStatusRequest,
    ) -> Result<FetchTaskBatchStatusResponse, twirp::ClientError> {
        let url = self
            .base_url
            .join("cluster.ClusterService/FetchTaskBatchStatus")?;
        self.request(url, req).await
    }
    async fn fetch_task_statuses(
        &self,
        req: FetchTaskStatusesRequest,
    ) -> Result<FetchTaskStatusesResponse, twirp::ClientError> {
        let url = self
            .base_url
            .join("cluster.ClusterService/FetchTaskStatuses")?;
        self.request(url, req).await
    }
    async fn update_task_status(
        &self,
        req: UpdateTaskStatusRequest,
    ) -> Result<UpdateTaskStatusResponse, twirp::ClientError> {
        let url = self
            .base_url
            .join("cluster.ClusterService/UpdateTaskStatus")?;
        self.request(url, req).await
    }
    async fn expire_dropped_tasks(
        &self,
        req: ExpireDroppedTasksRequest,
    ) -> Result<ExpireDroppedTasksResponse, twirp::ClientError> {
        let url = self
            .base_url
            .join("cluster.ClusterService/ExpireDroppedTasks")?;
        self.request(url, req).await
    }
    async fn get_fulfillable_proof_requests(
        &self,
        req: GetFulfillableProofRequestsRequest,
    ) -> Result<GetFulfillableProofRequestsResponse, twirp::ClientError> {
        let url = self
            .base_url
            .join("cluster.ClusterService/GetFulfillableProofRequests")?;
        self.request(url, req).await
    }
    async fn get_failed_proof_requests(
        &self,
        req: GetFailedProofRequestsRequest,
    ) -> Result<GetFailedProofRequestsResponse, twirp::ClientError> {
        let url = self
            .base_url
            .join("cluster.ClusterService/GetFailedProofRequests")?;
        self.request(url, req).await
    }
    async fn create_claimed_proof(
        &self,
        req: CreateClaimedProofRequest,
    ) -> Result<CreateClaimedProofResponse, twirp::ClientError> {
        let url = self
            .base_url
            .join("cluster.ClusterService/CreateClaimedProof")?;
        self.request(url, req).await
    }
    async fn update_proof_status(
        &self,
        req: UpdateProofStatusRequest,
    ) -> Result<UpdateProofStatusResponse, twirp::ClientError> {
        let url = self
            .base_url
            .join("cluster.ClusterService/UpdateProofStatus")?;
        self.request(url, req).await
    }
    async fn modify_cpu_cycles(
        &self,
        req: ModifyCpuCyclesRequest,
    ) -> Result<ModifyCpuCyclesResponse, twirp::ClientError> {
        let url = self
            .base_url
            .join("cluster.ClusterService/ModifyCpuCycles")?;
        self.request(url, req).await
    }
}
